<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <!-- https://chen-cong.blog.csdn.net/article/details/81211729?spm=1001.2014.3001.5506 -->
    <!-- 

        在理解原型链的过程中，要注意顾名思义，原型链是一个链式的继承链，虽然这条链有一些地方盘根交错互相交叉，
        但是要理解原型链，仍然要遵循链式继承一层一层向上溯源的思想去思考它，
        而不能去使用数学运算中类似于交换律、移项原则等思想去理解原型链(或者说是以我现在的水平还理解不够深刻，不满足使用这种思想的水平)

     -->
    <!-- 

        JS 中 Object 与 Function，__proto__ 与 prototype之间的关系

            首先明确第一点，JS认为万物皆Object，所以Function也是Object

            1、__proto__  
            
                是对象所独有的 ，__proto__属性都是由一个对象指向一个对象 ， 即指向它们的原型对象
                也就是说__proto__属性的所有者都是一个Object，该属性的指向也是一个Object，普通Object的__proto__都指向其构造Function的prototype

            2、prototype  

                是函数所独有的 ，prototype属性都是由一个函数指向一个对象 ， 它的含义是函数的原型对象 ， 也就是这个函数所创建的实例的原型对象
                也就是说prototype属性的所有者都是一个Function，该属性的类型是一个Object

                    obj.__proto__  ===  CreateObj.prototype

                    obj1.__proto__  ===  Object.prototype  ===  obj2.__proto__

                    以上就是二者间简单的关系 ：Object的__proto__都指向其构造Function的prototype

            3、当原型链的最开始，无论是Obj还是fn，都是作为Object来看待的
            
                1.函数的特殊性

                    但是问题就来了，Function也是属于Object的范畴，属于Object的一种，所以Function也拥有__proto__属性(只是在浏览器环境下并不能很直观的观察到)
                    把Function当做Object来对待，'普通Object的__proto__指向其构造Function的prototype'，常理来说普通函数无论作为普通函数还是构造函数，
                    其本身的构造函数都是JS内置的构造函数Function对象

                        fn.__proto__  ===  Function.prototype  === fn1.__proto__  ===  fn2.__proto__

                2.原型链的最开始

                    obj.__proto__  ——————>  CreateObj.prototype  

                    obj1.__proto__  ——————>  Object.prototype

                    fn.__proto__  ——————>  Function.prototype

                3.原型链的middle

                    在原型链的最开始，无论是Obj还是fn，都是作为Object来看待的，'普通Object的__proto__指向其构造Function的prototype'，但是prototype也是属于Object的范畴，
                    属于Object的一种，所以其本身也具有__proto__属性，根据'普通Object的__proto__指向其构造Function的prototype'，把prototype当做普通Object看待，
                    普通Object的__proto__的指向，也就是JS本身内置的Object构造函数的prototype，

                        CreateObj.prototype.__proto__  ===  Object.prototype

                        Function.prototype.__proto__  ===  Object.prototype

                4.原型链的end

                    上述总结发现：

                        1.原型链的最开始无论是Object，还是Function，都是作为Object看待，'普通Object的__proto__指向其构造Function的prototype',这就是开始

                                obj.__proto__  ——————>  CreateObj.prototype 

                                obj1.__proto__  ——————>  Object.prototype 

                                fn.__proto__  ——————>  Function.prototype

                        2.而无论是我们自定义的作为构造函数用的普通函数，还是JS本身内置的Function构造函数，作为函数看待其具有的prototype都可以当做普通Object，
                        '普通Object的__proto__指向其构造Function的prototype'，普通Object的__proto__的指向，也就是JS本身内置的Object构造函数的prototype，
                        也是中间的链式结构的终点，万法归一的一

                                CreateObj.prototype.__proto__  ===  Object.prototype

                                Function.prototype.__proto__  ===  Object.prototype

                        3.那么Object.prototype作为原型链万法归一的一，其实也是一个单纯的prototype，作为Object看待，遵循'普通Object的__proto__指向其构造Function的prototype'，
                        但是无论是自定义的构造函数，还是JS内置的构造函数，在理论中却找不到内置Object对象的构造函数，但是通过直接观察的方式，我们找到了Object.prototype.__proto__的指向

                                console.log(Object.prototype.__proto__)

                                Object.prototype.__proto__  ===  null  

                    
                    JS中万物皆Object，而null当为一切源头的终点，梦的尽头，JS世界中最远之处，至此，得见真理。 

                5.完整的原型链

                        obj.__proto__  ——————>  CreateObj.prototype  ——————>  CreateObj.prototype.__proto__  ——————>  Object.prototype  ——————>  Object.prototype.__proto__  ——————>  null

                        fn.__proto__  ——————>  Function.prototype  ——————>  Function.prototype.__proto__  ——————>  Object.prototype  ——————>  Object.prototype.__proto__  ——————>  null

                        obj1.__proto__  ——————>  Object.prototype  ——————>  Object.prototype.__proto__  ——————>  null

            4、当原型链的开始不是普通Object，而是普通Fucntion

                1.原型链的开始

                    作为普通函数看待，函数的专属属性为prototype，prototype也是属于Object的范畴，属于Object的一种，所以其本身也具有__proto__属性，
                    根据'普通Object的__proto__指向其构造Function的prototype'，把prototype当做普通Object看待，普通Object的__proto__的指向，
                    也就是JS本身内置的Object构造函数的prototype，

                        CreateObj.prototype  ——————>  CreateObj.prototype.__proto__  ——————>  Object.prototype

                2.原型链又到了Object.prototype这个万法归一的一，之后的middle和end上述已有介绍。

                3.完整的原型链对比

                    obj.__proto__  ——————>  CreateObj.prototype  ——————>  CreateObj.prototype.__proto__  ——————>  Object.prototype  ——————>  Object.prototype.__proto__  ——————>  null
                
                    CreateObj.__proto__  ——————>  Function.prototype  ——————>  Function.prototype.__proto__  ——————>  Object.prototype  ——————>  Object.prototype.__proto__  ——————>  null
                              
                                                    CreateObj.prototype  ——————>  CreateObj.prototype.__proto__  ——————>  Object.prototype  ——————>  Object.prototype.__proto__  ——————>  null

                当原型链的最开始的Function不是作为普通Object，而是作为普通Function，只是将原来该函数作为构造函数的原型链中的开始部分拿掉了而已

            5、内置的Object以及内置的Function

                在JS内部有很多已经被内置的构造函数，Array、Date、Map、Number...，但是我认为这些都是内置Object构造函数的变种而已，他们并不值得去进行深入探讨，
                值得我们去研究的只有内置的Object以及内置的Function，两个构造函数，在通过上述原型链的解释中，我们也能够看到二者的特殊性。
                二者都即可以作为普通Function来看待，又可以作为普通Object来看待.

                1.Object作为函数看待，其原型对象Object.prototype是所有原型链万法归一的'一'

                    Object.prototype  ——————>  Object.prototype.__proto__  ——————>  null

                2.Function作为函数看待，只是一个普通函数而已，其原型对象的原型链上级是Object.prototype，最终还是归到了'一'

                    Function.prototype  ——————>  Function.prototype.__proto__  ——————>  Object.prototype

                3.Object作为对象看待，Function是其构造函数

                    Object.__proto__  ——————>  Function.prototype  

                4.Function作为对象看待，Function是其本身的构造函数

                    Function.__proto__  ——————>  Function.prototype
                
                5.四条完整的原型链
                
                    Object.prototype  ——————>  Object.prototype.__proto__  ——————>  null

                    Function.prototype  ——————>  Function.prototype.__proto__  ——————>  Object.prototype  ——————>  Object.prototype.__proto__  ——————>  null

                    Object.__proto__  ——————>  Function.prototype  ——————>  Function.prototype.__proto__  ——————>  Object.prototype  ——————>  Object.prototype.__proto__  ——————>  null

                    Function.__proto__  ——————>  Function.prototype  ——————>  Function.prototype.__proto__  ——————>  Object.prototype  ——————>  Object.prototype.__proto__  ——————>  null

                6.总结

                    1.JS内置的Function是JS内置的所有构造函数的终极构造函数，包括其自身

                        Object.__proto__===Function.prototype
                        Array.__proto__===Function.prototype
                        Date.__proto__===Function.prototype
                        Function.__proto__===Function.prototype 

                        所有构造函数作为Object来看待时，JS内置Function时所有函数的构造函数

                    2.所有构造函数的prototype实例对象的构造函数是Object，所以所有原型链都会万法归一，归到 Object.prototype  ——————>  null

                        Object.__proto__  ——————>  Function.prototype  ——————>  Object.prototype 
                        Function.prototype  ——————>  Object.prototype
                        Array.prototype  ——————>  Function.prototype
                        Date.prototype  ——————>  Function.prototype

                        CreateObj.prototype  ——————>  Object.prototype
                        obj1.__proto__  ——————>  Object.prototype

                        Object.prototype是一切原型链的终点，Function是一切函数的构造函数。

            6、关于原型链

                1.__proto__  

                    是对象所独有的 ，__proto__属性都是由一个对象指向一个对象 ， 即指向它们的原型对象
                    也就是说__proto__属性的所有者都是一个Object，该属性的指向也是一个Object，普通Object的__proto__都指向其构造Function的prototype

                    作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的__proto__属性所指向的那个对象（可以理解为父对象，其构造Function的prototype）里找，
                    如果父对象也不存在这个属性，则继续往父对象的__proto__属性所指向的那个对象里找，如果还没找到，则继续往上找…直到原型链顶端null

                    这种通过__proto__属性来连接对象直到null的一条链即为我们所谓的原型链

                2.prototype  

                    是函数所独有的 ，prototype属性都是由一个函数指向一个对象 ， 它的含义是函数的原型对象 ， 也就是这个函数所创建的实例的原型对象
                    也就是说prototype属性的所有者都是一个Function，该属性的类型是一个Object

                    作用就是包含可以由特定类型的所有实例共享的属性和方法，也就是让该函数所实例化的对象们都可以找到公用的属性和方法。
                    任何函数在创建的时候，其实会默认同时创建该函数的prototype对象。

                    (以及被__proto__指)

     -->
    <script>
        //   Object
        var CreateObj = function () {}
        var obj = new CreateObj()
        var obj1 = new Object()
        var obj2 = {}

        //观察  普通Object的__proto__都指向其构造Function的prototype
        console.log(obj.__proto__ === CreateObj.prototype) //obj的构造Function是CreateObj
        console.log(obj1.__proto__ === Object.prototype) //obj1的构造Function是Object ，js原生内置对象构造函数
        console.log(obj2.__proto__ === Object.prototype) //obj2的构造Function是Object ，js原生内置对象构造函数
        console.log(obj1.__proto__ === obj2.__proto__) //

        //   Function
        function fn() {}
        var fn1 = new Function()
        var fn2 = function () {}

        //观察 把Function当做Object来对待，Object的__proto__指向其构造函数的prototype，
        console.log(fn.__proto__ === Function.prototype) //fn的构造Function是Function ，js原生内置函数构造函数
        console.log(fn1.__proto__ === Function.prototype) //fn1的构造Function是Function ，js原生内置函数构造函数
        console.log(fn2.__proto__ === Function.prototype) //fn2的构造Function是Function ，js原生内置函数构造函数
        console.log(fn.__proto__ === fn1.__proto__)
        console.log(fn.__proto__ === fn2.__proto__)

        //观察 构造Function的prototype，也可以作为普通Object看待，所以普通Object的__proto__都指向其构造Function的prototype，
        console.log(CreateObj.prototype.__proto__ === Object.prototype)
        console.log(Function.prototype.__proto__ === Object.prototype)

        //观察 在原型链万法归一后，却在理论上找不到Object.prototype的更上层，通过直接观察的方式发现Object.prototype.__proto__指向null
        console.log(Object.prototype.__proto__)
        console.log(Object.prototype.__proto__ === null)

        console.log(Object.prototype === Function.prototype) //false

        //观察 Function是一切的构造函数，包括其自身
        console.log(Object.__proto__ === Function.prototype)
        console.log(Function.__proto__ === Function.prototype)

        console.log(Array.__proto__ === Function.prototype)
        console.log(Date.__proto__ === Function.prototype)
    </script>
</body>

</html>