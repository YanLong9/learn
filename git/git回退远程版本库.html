<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <!-- 

      1、回退本地版本库
      
          git reset --soft <hash>                   

            将HEAD指针指向commitID对应的提交，但是不会操作暂存区和工作区，
            当前分支中的最新提交会变成commitID对应的提交，工作区和暂存区中的内容或者变更不会受到任何影响

          git reset <hash>                          
                    
            HEAD指针以及暂存区中的内容都发生了变化，但是不会影响工作区，
            也就是说，当前分支的最新提交会变成commitID对应的提交，对应提交的状态会同步到暂存区，但是工作区中的内容或者变更不受影响

          git reset --hard <hash>

            HEAD指针、暂存区，以及工作区全部回到了指定提交时的状态，由于HEAD指针的指向也发生了变化，所以当前分支的最新提交也会变成commitID对应的提交

      2、回退远程版本库的私人分支

        1.首先回退本地版本库

          git reset --hard <hash>           回退本地版本库到指定的历史提交节点状态，本地版本库的HEAD指针、暂存区、工作区都会回退到指定状态。

        2.然后使用强制提交

          git push --force
          git push -f                       使用强制提交，将本地版本库的状态提交到远程对应分支。

            如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做git pull合并差异，然后再推送到远程主机。
            这时，如果你一定要推送，可以使用--force选项。

          使用强制提交的话，就是将本地分支的目前状态强制更新到对应的远程分支，如果产生冲突，则以本地分支的状态为准，
          包括本地的历史提交节点记录，本地分支目前所处的提交节点，远程会将与本地同步。

            1.如果远程的历史提交节点记录，相较于本地的更加新       
            
              远程分支的节点记录将会被回退至本地分支目前的提交节点，目前提交节点之后的提交节点会被删除

            2.如果远程分支的历史提交节点记录与本地同步

              只是相当于产生了一次普通提交

            3.如果远程分支的历史提交节点记录，相较于本地的更旧


        3.问题

          使用强制提交来做远程版本库的版本回退，会导致远程版本库对应分支的历史提交节点记录也会回退到对应的提交节点
          并且在该节点之后的提交节点会被删除，这样就会导致



      3、回退远程版本库的公共分支

        

   -->
</body>

</html>